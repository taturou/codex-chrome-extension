import { createHash } from "node:crypto";
import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");
const manifestJsonPath = path.join(projectRoot, "public", "manifest.json");
const outputPath = path.join(projectRoot, "src", "shared", "manifestPolicy.ts");

function normalizeOrigins(values) {
  if (!Array.isArray(values)) {
    return [];
  }
  const normalized = values
    .filter((value) => typeof value === "string")
    .map((value) => value.trim())
    .filter((value) => value.length > 0);
  return Array.from(new Set(normalized)).sort((a, b) => a.localeCompare(b));
}

function extractPolicy(manifest) {
  return {
    hostPermissions: normalizeOrigins(manifest.host_permissions),
    optionalHostPermissions: normalizeOrigins(manifest.optional_host_permissions),
  };
}

function toPolicyJson(policy) {
  return JSON.stringify({
    hostPermissions: policy.hostPermissions,
    optionalHostPermissions: policy.optionalHostPermissions,
  });
}

async function syncManifestPolicy() {
  const manifest = JSON.parse(await readFile(manifestJsonPath, "utf8"));
  const policy = extractPolicy(manifest);
  const hash = createHash("sha256").update(toPolicyJson(policy), "utf8").digest("hex");

  const content = `// This file is auto-generated by scripts/sync-manifest-policy.mjs
// Do not edit manually.
export const EXPECTED_PERMISSION_POLICY_SHA256 = '${hash}';
`;
  await writeFile(outputPath, content, "utf8");
  console.log(`Synced permission policy hash: ${hash}`);
}

syncManifestPolicy().catch((error) => {
  console.error(error.message);
  process.exit(1);
});
